#!/usr/bin/env bash

print_doc () {
    echo \
"Build an autotools-based library as native library for Android.

SYNOPSIS
  $(basename $0)

OPTIONS
  -h  Print this help text and exit.

DESCRIPTION
  Cross-compile a shared library with a configuration system based on
  autotools for Android. The resulting library should be suitable for
  inclusion into an Android application as a native library. The script needs
  to have access to Android NDK.

  The script first downloads the source tarball for the given library, unpacks
  the sources into a temporary directory and then runs configure, make all,
  and make install. Several environment variables are overriden before
  configure is called to make sure that the configure script knows that we're
  cross-compiling.

  Because the linker on Android doesn't support versioned libraries created by
  libtool by default, we need to modify the resulting binary and remove the
  ABI version suffix from its SONAME. This is an ungly hack, but hopefully a
  future version of Android NDK will handle pre-built shared libraries better.

  To use the pre-build library, include the generated Android.mk in your
  project's jni/Android.mk. For example (for libcurl):

  ...
  LOCAL_SHARED_LIBRARIES := curl
  include \$(BUILD_SHARED_LIBRARY)
  include \".../android-libs/curl/curl-7.28.0/Android.mk\"
  ...

  Note: If the JNI library in your Android project depends on a pre-build
  shared library (like libcurl), you may need to load the pre-build shared
  library explicitly with something like:

  System.loadLibrary(\"curl\");

  It appears that the Android linker cannot handle native library dependencies
  correctly (at least on Android 4.2).

RETURN VALUE
  The script returns 0 on success and a non-zero value if it failed to build
  the library.

ENVIRONMENT VARIABLES
  You can customize the build by setting the following environment variables:

  NAME          The name of the library being built
  VERSION       Library version
  TARBALL       Source tarball name [$NAME-$VERSION.tar.gz]
  URL           The URL to download the source tarball from (optional)
  TOOLCHAIN     Target Android architecture [arm-linux-androideabi-4.6]
  PLATFORM      Target Android platform [android-3]

AUTHORS
  Jan Janak <jan@janakj.org>
"
}

bail () {
    echo "ERROR: $@" >&2
    exit 1
}

# Make a standalone version of cross-compiler tools from Android NDK and
# install them into the directory specified in $1. Add the correct
# subdirectory with executable tools to PATH. Override the environment
# variable CC with the correct compiler for cross-compilation. Set the
# variable $prefix to a string suitable for the --host command line option of
# configure.
make_tools () {
    # Provide a default toolchain name if the caller didn't specify any
    TOOLCHAIN=${TOOLCHAIN:-arm-linux-androideabi-4.6}

    # Detect Android SDK and NDK and make sure all directories and tools are
    # there.
    android_sdk=$(which android | sed -Ee 's@(.*)/tools/android@\1@')
    [ -z "$android_sdk" ] && bail "Android SDK not found"

    # If you install NDK from the android manager tool, it will be located in
    # the ndk subdirectory of Android SDK.
    android_ndk="$android_sdk/ndk"
    [ -d "$android_ndk" ] || bail "Android NDK not found"

    # Extract CPU type from the toolchain name.
    arch=$(echo "$TOOLCHAIN" | cut -d - -f 1)
    prefix=$(echo "$TOOLCHAIN" | sed -Ee 's/^(.*)-[^-]+$/\1/')

    opts="--arch=$arch"
    [ -n "$TOOLCHAIN" ] && opts+=" --toolchain=$TOOLCHAIN"
    [ -n "$PLATFORM" ] && opts+=" --platform=$PLATFORM"

    [ -d "$1" ] || {
	script="$android_ndk/build/tools/make-standalone-toolchain.sh"
	$script $opts --install-dir="$1"
	[ $? -ne 0 ] && {
	    bail "Script failed: $script $opts --install-dir=\"$1\""
	}
    }

    export PATH="$1/bin:$PATH"
    export CC=$prefix-gcc
}

# Find all shared libraries installed into $1. Return the list of libraries
# found in $libs. Report error if no shared libraries were found.
find_libs () {
    # Find all shared libraries
    libs=$(cd $1; find "usr/lib" -type f -name "*.so.*" -print)
    [ -z "$libs" ] && bail "Can't find any shared libraries"
}

# HACK: Remove the version suffix from the SONAME string in given
# libraries. Argument $1 is the target directory, the remaining arguments are
# relative pathnames (wrt the target directory) of libraries to work with. The
# function removes the file ending with .so if it exists (it's usually a
# symbolic link) and stores the modified version of the library (with the
# version suffix removed from the SONAME) under that name.
#
# The function returns a list of modified library names with paths relative to
# the target directory. The list is suitable for inclusion into Android.mk.
#
# This hack is necessary because the APK builder tool only installs shared
# libraries whose filenames end with .so. The Android linker would not be able
# to link the library if the SONAME string in the library's filename doesn't
# match the SONAME string. An alternative would be to install the versioned
# library into the APK package manually.
fix_soname () {
    dir="$1"
    shift
    src_files=$(cd $dir
    unset libs
    for l in $@ ; do
	dir="$(dirname $l)"
	old=$($prefix-objdump $l -p | grep SONAME | sed -Ee \
	    's/^[ \t]*SONAME[ \t]+(.*)$/\1/')
	[ -z "$old" ] && bail "Can't find SONAME for $dir/$l"

	new=$(echo $old | sed -Ee 's/(^.+\.so)(\.[0-9]+)+/\1/')
	padding=$(echo $old | sed -Ee 's/^.+\.so(\.[0-9]+)+$/\1/' | sed -Ee \
	    's/./\\000/g')

	rm -f "$dir/$new" >/dev/null 2>&1
	cp "$l" "$dir/$new" >/dev/null 2>&1
	perl -pi -e "s/$old/$new$padding/" "$dir/$new" >/dev/null 2>&1
	libs+=" $dir/$new"
    done
    echo $libs)
}

# Create the file Android.mk for the Android NDK build system. The file should
# be created in the directory passed to the function in $1. The name of the
# module will be obtained from $NAME. Library filenames are taken from
# arguments $2...
create_android_mk () {
    dir="$1"
    shift
    # Export header files if we have them
    [ -d "$dir/usr/include" ] && {
	extra="LOCAL_EXPORT_C_INCLUDES := \$(LOCAL_PATH)/usr/include"
    }

    # Prepare the list of src files, relative to $LOCAL_PATH
    unset files
    for l in $@ ; do files+="\$(LOCAL_PATH)/$l "; done

    cat >"$dir/Android.mk" <<EOF
LOCAL_PATH := \$(call my-dir)

include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_SRC_FILES := $files
$extra
include \$(PREBUILT_SHARED_LIBRARY)
EOF
}

# If we have patches, copy them over to $1 and apply all of them using
# quilt. The function needs to be run from the directory containing the
# "patches" subdirectory.
apply_patches () {
    [ -d "patches" ] || return 0
    cp -a patches "$1"
    (cd "$1"; quilt push -a)
    [ $? -ne 0 ] && bail "Error while applying patches."
}

# Run the autoreconf script.
declare -f run_autoreconf >/dev/null || run_autoreconf () {
    [ -x "$(which libtoolize)" ] || {
        # A hack for Mac OS X. Libtool installed from Mac ports installs
        # libtoolize as glibtoolize.
	[ -x "$(which glibtoolize)" ] || bail "Cannot find libtoolize."
	glibtoolize
    }
    # Otherwise the script runs libtoolize internally.
    autoreconf
}

# Run the configure script. Cross-compile for the target architecture in $1
# and configure libraries and header file to be installed under /usr. Gets the
# absolute name of the destination directory to install into in $2.
declare -f run_configure >/dev/null || run_configure () {
    run_autoreconf
    ./configure --host=$1 --prefix=/usr
}

# Build all the libraries. Gets the absolute name of the destination directory
# to install into in $1.
declare -f run_build >/dev/null || run_build () {
    make all
}

# Install library files and header files. NOTE: The build system MUST install
# all the files under $1!
declare -f run_install >/dev/null || run_install () {
    DESTDIR="$1" make install
}

[ $# -gt 0 ] && {
    print_doc
    exit 0
}

[ -z "$root" ] && bail "Variable \$root not set by calling script."

# Make sure we have all the tools this script needs.
for t in wget quilt perl make autoreconf mktemp android sed sort tail ls \
    find mkdir cp ; do
    [ -x "$(which $t)" ] || bail "Couldn't execute $t command."
done

# The default tarball naming pattern to use if the caller didn't provide a
# different source tarball name.
TARBALL=${TARBALL:-$NAME-$VERSION.tar.gz}

cd $(dirname $0)
root="$(pwd)/$root"
sysroot="$root/toolchain/sysroot"

# Download the source tarball if we don't have it yet.
[ -r "$TARBALL" ] || {
    [ -z "$URL" ] && {
        bail "No tarball found and no download URL provided"
    }
    wget "$URL"
    [ $? -ne 0 ] && bail "Can't download source tarball from $URL"
}

# Create a temporary directory
tmp="$(mktemp -d /tmp/build-$NAME-$VERSION-XXXXXX)"
trap 'rm -rf "$tmp"' EXIT

make_tools "$root/toolchain"
tar -C "$tmp" -xvf "$TARBALL"
apply_patches $tmp

# Prepare the destination directory for install. We name the environment
# variable DESTDIR because that's the name picked up by Makefile generated by
# automake and autoconf.
export DESTDIR="$(pwd)/$NAME-$VERSION"
[ -d "$DESTDIR" ] && rm -rf "$DESTDIR"
mkdir -p "$DESTDIR"

export PKG_CONFIG_SYSROOT_DIR="$sysroot"
export PKG_CONFIG_LIBDIR=$PKG_CONFIG_SYSROOT_DIR/usr/lib/pkgconfig/

(set -e
 cd $tmp/${NAME}-${VERSION};
 run_configure $prefix $DESTDIR
 run_build $DESTDIR
 run_install $DESTDIR
 run_install "$sysroot"
)
[ $? -ne 0 ] && bail "Error while building the library."

find_libs $DESTDIR
fix_soname $DESTDIR $libs
fix_soname "$sysroot" $libs
create_android_mk $DESTDIR $src_files
